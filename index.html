<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Books & Chapters — Enrich (DOI/Title) · Clean · Audit</title>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<style>
  :root{--bg:#0b1020;--panel:#121833;--card:#0f152a;--line:#1f2747;--ink:#e9eef9;--mut:#9fb0e1;--accent:#1463ff}
  *{box-sizing:border-box}
  body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--ink);margin:0}
  .wrap{max-width:1200px;margin:24px auto;padding:24px;background:var(--panel);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  h1{margin:0 0 12px;font-size:22px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:14px;margin-top:12px}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:14px}
  .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:14px}
  label{font-size:13px;opacity:.92}
  select,input[type="text"],input[type="email"],input[type="number"],input[type="range"]{width:100%;padding:10px;border-radius:10px;border:1px solid #31406d;background:#0b1130;color:var(--ink)}
  .pill{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border:1px solid #34406b;border-radius:999px;font-size:12px;margin:4px 6px 0 0}
  .muted{font-size:12px;color:var(--mut)}
  .btn{padding:10px 14px;border:1px solid #2a8cff;background:var(--accent);color:#fff;border-radius:10px;cursor:pointer}
  .btn.secondary{background:transparent;border-color:#3a4d86}
  .btn:disabled{opacity:.55;cursor:not-allowed}
  progress{width:100%}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .stat{display:inline-block;margin-right:14px;font-size:12px;color:var(--mut)}
  .preview{font-size:12px;color:var(--mut);margin-top:6px}
</style>
</head>
<body>
<div class="wrap">
  <h1>Books & Chapters — Enrich (DOI/Title), Clean, Audit</h1>

  <!-- Load + sheet -->
  <div class="card">
    <div class="row">
      <div>
        <label><b>Upload file (CSV/XLSX)</b></label>
        <input id="file" type="file" accept=".csv,.xlsx,.xls" />
        <div class="muted">Needs columns for Title, Authors, DOI (ISSN/ISBN/Year optional).</div>
      </div>
      <div>
        <label><b>Contact email for Crossref (required)</b></label>
        <input id="mailto" type="email" placeholder="you@org.ac.in" />
        <div class="muted">Used only in the Crossref request header.</div>
      </div>
    </div>
    <div class="row" style="margin-top:10px">
      <div>
        <label>Sheet</label>
        <select id="sheetSel"></select>
      </div>
      <div>
        <div id="hdrPreview" class="preview"></div>
      </div>
    </div>
  </div>

  <!-- Column mapping -->
  <div class="card">
    <div class="row3">
      <div><label>Title column</label><select id="colTitle"></select></div>
      <div><label>Authors column</label><select id="colAuthors"></select></div>
      <div><label>DOI column</label><select id="colDOI"></select></div>
    </div>
    <div class="row3" style="margin-top:10px">
      <div><label>ISSN column (optional)</label><select id="colISSN"></select></div>
      <div><label>ISBN column (optional)</label><select id="colISBN"></select></div>
      <div><label>Publication type column (optional)</label><select id="colType"></select></div>
    </div>
    <div class="row3" style="margin-top:10px">
      <div><label>Year column (optional)</label><select id="colYear"></select></div>
      <div class="k">
        <label>Title-match threshold <span id="thrVal" class="muted"></span></label>
        <input id="thr" type="range" min="0.50" max="0.90" step="0.01" value="0.68" />
        <div class="muted">Used when DOI is missing.</div>
      </div>
      <div class="k">
        <label>Year tolerance (±)</label>
        <input id="tolYear" type="number" min="0" max="3" value="1" />
        <div class="muted">Used only if Year column is mapped.</div>
      </div>
    </div>
  </div>

  <!-- Options + actions -->
  <div class="card">
    <div class="pill"><input id="opt_fixTitle" type="checkbox" checked /> Proper-case titles (keep ACRONYMS; small articles/preps/conj lowercase)</div>
    <div class="pill"><input id="opt_preferDOITitle" type="checkbox" checked /> Prefer DOI/Crossref title (use subtitle if present)</div>
    <div class="pill"><input id="opt_fixAuthors" type="checkbox" checked /> Normalize authors → “First Last”</div>
    <div class="pill"><input id="opt_useCrossref" type="checkbox" checked /> Enrich from Crossref</div>
    <div class="pill"><input id="opt_useCache" type="checkbox" checked /> Cache lookups (localStorage)</div>

    <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:10px">
      <button id="btnExportCache" class="btn secondary" disabled>Export cache</button>
      <button id="btnClearCache" class="btn secondary">Clear cache</button>
      <button id="btnProcess" class="btn" disabled>Process</button>
      <button id="btnDownload" class="btn secondary" disabled>Download XLSX</button>
    </div>
    <div id="status" class="muted" style="margin-top:8px">No file loaded.</div>
    <div id="progWrap" style="display:none;margin-top:8px"><progress id="prog" value="0" max="100"></progress></div>
    <div id="stats" class="preview"></div>
  </div>

  <div class="card">
    <b>Outputs</b>
    <div class="muted">
      <ul>
        <li><b>Cleaned</b> — CleanTitle, CleanAuthors, DOI, Publisher, ISSN, ISBN, PubType, SourceTitle, MatchMethod, MatchConfidence, MatchNote, IsDuplicate, DupGroupSize</li>
        <li><b>UniqueAuthors</b> — CanonicalAuthor, Occurrences, SeenVariants</li>
        <li><b>Duplicates</b> — only duplicate rows</li>
        <li><b>Deduped</b> — first row per duplicate group</li>
        <li><b>Audit</b> — per-row enrichment details (for QA)</li>
      </ul>
    </div>
  </div>
</div>

<script>
/* ================================
   Scientist-Programmer core (final)
   — DOI+subtitle title fix + dedupe —
   ================================ */

let wb=null, rawRows=[], headers=[], processed=[], audit=[], unmatched=[];
let sourceTitleGuess=null;

/*** --- Config --- ***/
const POLITE_DELAY_MS = 220;  // Crossref pacing
const CACHE_KEY = "crCache_v4";

/*** --- Utilities --- ***/
const stopwords = new Set([
  "a","an","the","and","but","or","nor","for","so","yet",
  "at","by","in","of","off","on","per","to","up","via","vs","as",
  "over","into","onto","from","than","with","without","within","about","across","after","before","between","through","under","above","around"
]);
const particles = new Set(["van","von","de","del","della","der","den","da","dos","das","di","al","bin","ibn","la","le","du","ter"]);

function normSpace(s){ return (s??"").toString().replace(/\s+/g," ").trim(); }
function isAcronym(w){ return /^[A-Z0-9]{2,}$/.test(w); }
function capitalizeWord(w){
  if(!w) return w;
  if(isAcronym(w)) return w;
  if(w.includes("-")) return w.split("-").map(capitalizeWord).join("-");
  return w.charAt(0).toUpperCase() + w.slice(1).toLowerCase();
}
function properCaseTitle(str){
  str = normSpace(str); if(!str) return str;
  const words = str.split(" ");
  return words.map((w,i)=>{
    const base = w.replace(/[^\w\-']/g,"");
    if(i!==0 && i!==(words.length-1) && stopwords.has(base.toLowerCase())) return w.toLowerCase();
    return capitalizeWord(w);
  }).join(" ");
}
function toFirstLast_one(name){
  name = normSpace(name.replace(/\s*\.\s*/g,".").replace(/\s+,/g,","));
  if(!name) return "";
  if(name.includes(",")){
    const [last,rest]=name.split(",",2);
    let parts = normSpace(`${rest||""} ${last}`).split(" ").filter(Boolean);
    parts = parts.map((p)=> particles.has(p.toLowerCase()) ? p.toLowerCase() : capitalizeWord(p));
    return parts.join(" ");
  }
  return name.split(" ").map(p=>particles.has(p.toLowerCase())?p.toLowerCase():capitalizeWord(p)).join(" ");
}
function normalizeAuthors(str){
  if(!str) return "";
  let parts=[];
  if(str.includes("|")) parts=str.split("|");
  else if(str.includes(";")) parts=str.split(";");
  else parts=str.split(/\s+and\s+|\s*&\s*/i);
  return parts.map(x=>x.trim()).filter(Boolean)
    .map(toFirstLast_one)
    .map(normSpace)
    .join("; ");
}
function firstAuthorSurnameGuess(str){
  if(!str) return "";
  let first = str.split("|")[0].split(";")[0].trim();
  if(!first) return "";
  if(first.includes(",")) return normSpace(first.split(",")[0]).toLowerCase();
  const toks = first.split(" ").filter(Boolean);
  return toks.length ? toks[toks.length-1].toLowerCase() : "";
}
function pick(a){ return Array.isArray(a)?a:(a?[a]:[]); }
function joinUnique(arr){ return Array.from(new Set(arr.filter(Boolean).map(x=>x.toString().trim()))).join("; "); }
function doiNormalize(d){ if(!d) return ""; d=d.toString().trim(); return d.replace(/^https?:\/\/(dx\.)?doi\.org\//i,""); }

/*** --- Duplicate key --- ***/
function normTitleForMatch(s){
  return normSpace(s.toLowerCase()
    .replace(/[\u2010-\u2015]/g,"-")
    .replace(/[^\w\s-]/g,""))
    .split(" ")
    .filter(w=>w && !stopwords.has(w))
    .join(" ");
}
// prefer DOI; else Title + first-author surname + Year
function makeDupKey(row){
  const doi = (row.DOI || "").toLowerCase().trim();
  if(doi) return `doi:${doi}`;
  const t  = normTitleForMatch(row._OriginalTitle || row.CleanTitle || "");
  const fa = (firstAuthorSurnameGuess(row._OriginalAuthors || row.CleanAuthors) || "").toLowerCase();
  const y  = (row._Year || "").toString().trim();
  return `t:${t}|a:${fa}|y:${y}`;
}

/*** --- Title similarity (used when DOI missing) --- ***/
function jaccard(a,b){
  const A=new Set(a.split(" ").filter(Boolean));
  const B=new Set(b.split(" ").filter(Boolean));
  const inter=[...A].filter(x=>B.has(x)).length;
  const uni=new Set([...A,...B]).size||1;
  return inter/uni;
}
function confidenceFromFeatures({jac, authorHit, yearOk}){
  let s = jac;
  if(authorHit) s += 0.12;
  if(yearOk)    s += 0.08;
  return Math.max(0, Math.min(1, s));
}

/*** --- Cache --- ***/
function getCache(){ try{ return JSON.parse(localStorage.getItem(CACHE_KEY)||"{}"); }catch{ return {}; } }
function setCache(o){ try{ localStorage.setItem(CACHE_KEY, JSON.stringify(o)); }catch{} }
function cacheGet(k){ return getCache()[k]; }
function cacheSet(k,v){ const c=getCache(); c[k]=v; setCache(c); }

/*** --- Crossref API --- ***/
async function fetchCrossrefByDOI(doi, mailto){
  const key = `doi::${doi.toLowerCase()}`;
  if(document.getElementById("opt_useCache").checked){
    const hit = cacheGet(key); if(hit) return hit;
  }
  const res = await fetch(`https://api.crossref.org/works/${encodeURIComponent(doi)}`,{
    headers:{ "User-Agent":`UPES-RnD-Scientist/1.5 (mailto:${mailto||"unknown@example.com"})`, "Accept":"application/json" }
  });
  if(!res.ok) return null;
  const j = await res.json();
  const msg = j?.message||null;
  if(msg && document.getElementById("opt_useCache").checked) cacheSet(key,msg);
  return msg;
}
async function searchCrossrefByTitle({title, firstAuthor, mailto, pubTypeGuess, year, yearTol}){
  const key = `title::${title.toLowerCase()}::${(firstAuthor||"").toLowerCase()}::${pubTypeGuess||""}::${year||""}::${yearTol||0}`;
  if(document.getElementById("opt_useCache").checked){
    const hit = cacheGet(key); if(hit) return hit;
  }
  const params=new URLSearchParams();
  params.set("query.title", title);
  if(firstAuthor) params.set("query.author", firstAuthor);
  params.set("rows","8");
  params.set("select","title,subtitle,DOI,author,issued,publisher,type,ISSN,ISBN,container-title,score");
  const filters=[];
  if(pubTypeGuess && /book/i.test(pubTypeGuess)) filters.push("type:book,type:book-chapter");
  if(year){
    const y = parseInt(year,10);
    const tol = Math.max(0, parseInt(yearTol||0,10));
    filters.push(`from-pub-date:${y - tol}-01-01`);
    filters.push(`until-pub-date:${y + tol}-12-31`);
  }
  if(filters.length) params.set("filter", filters.join(","));
  const res = await fetch(`https://api.crossref.org/works?${params.toString()}`,{
    headers:{ "User-Agent":`UPES-RnD-Scientist/1.5 (mailto:${mailto||"unknown@example.com"})`, "Accept":"application/json" }
  });
  if(!res.ok) return [];
  const j = await res.json();
  const items = j?.message?.items || [];
  if(document.getElementById("opt_useCache").checked) cacheSet(key, items);
  return items;
}

/*** --- Build full title from Crossref (title + subtitle) --- ***/
function buildCrossrefFullTitle(meta){
  const main = pick(meta.title)[0] || "";
  const sub  = pick(meta.subtitle)[0] || "";
  if(main && sub){
    // avoid double colon if main already ends with ":" or " -"
    const sep = /[:\-]\s*$/.test(main) ? " " : ": ";
    return main + sep + sub;
  }
  return main || sub || "";
}

/*** --- Header detection --- ***/
function inferHeaderAndRows(ws){
  const rows = XLSX.utils.sheet_to_json(ws,{header:1,defval:""});
  let bestIdx=0,bestScore=-1;
  const scanLimit=Math.min(rows.length,20);
  for(let i=0;i<scanLimit;i++){
    const r=rows[i]||[];
    const filled=r.filter(x=>String(x).trim()!=="").length;
    if(filled>bestScore){bestScore=filled;bestIdx=i;}
  }
  const hdr=(rows[bestIdx]||[]).map(x=>normSpace(String(x)));
  const out=[];
  for(let i=bestIdx+1;i<rows.length;i++){
    const r=rows[i]||[];
    const obj={};
    for(let c=0;c<hdr.length;c++){
      const key=hdr[c]||`Col${c+1}`;
      obj[key]=r[c]??"";
    }
    if(Object.values(obj).some(v=>String(v).trim()!=="")) out.push(obj);
  }
  return {headers: hdr.map(h=>h||"Unnamed"), rows: out};
}

/*** --- UI Refs --- ***/
const fileEl = document.getElementById("file");
const sheetSel = document.getElementById("sheetSel");
const mailtoEl = document.getElementById("mailto");
const statusEl = document.getElementById("status");
const statsEl = document.getElementById("stats");
const btnProcess = document.getElementById("btnProcess");
const btnDownload = document.getElementById("btnDownload");
const btnExportCache = document.getElementById("btnExportCache");
const btnClearCache = document.getElementById("btnClearCache");
const prog = document.getElementById("prog");
const progWrap = document.getElementById("progWrap");
const thr = document.getElementById("thr");
const thrVal = document.getElementById("thrVal");
const tolYearEl = document.getElementById("tolYear");
const hdrPreview = document.getElementById("hdrPreview");

const selTitle = document.getElementById("colTitle");
const selAuthors = document.getElementById("colAuthors");
const selDOI = document.getElementById("colDOI");
const selISSN = document.getElementById("colISSN");
const selISBN = document.getElementById("colISBN");
const selType = document.getElementById("colType");
const selYear = document.getElementById("colYear");

thrVal.textContent = `(=${thr.value})`;
thr.addEventListener("input", ()=> thrVal.textContent=`(=${thr.value})`);

/*** --- Column mapping helpers --- ***/
function fillSelect(id, headers){
  const el = document.getElementById(id);
  el.innerHTML = '<option value="">-- none --</option>' + headers.map(h=>`<option>${h}</option>`).join("");
}
function autoMap(){
  sourceTitleGuess = headers.find(h => /source\s*title|book\s*title|journal\s*title|scopus\s*source/i.test(h)) || null;
  ["colTitle","colAuthors","colDOI","colISSN","colISBN","colType","colYear"].forEach(id=>fillSelect(id, headers));
  selTitle.value   = headers.find(h=>/^title$/i.test(h)) || headers.find(h=>/chapter|book.*title/i.test(h)) || "";
  selAuthors.value = headers.find(h=>/author/i.test(h)) || "";
  selDOI.value     = headers.find(h=>/^doi$/i.test(h)) || "";
  selISSN.value    = headers.find(h=>/issn/i.test(h)) || "";
  selISBN.value    = headers.find(h=>/isbn/i.test(h)) || "";
  selType.value    = headers.find(h=>/type/i.test(h)) || "";
  selYear.value    = headers.find(h=>/^year$|published|date/i.test(h)) || "";
  hdrPreview.textContent = headers.length ? `Detected headers: ${headers.join(" | ")}` : "";
}

/*** --- File handling --- ***/
fileEl.addEventListener("change", async (e)=>{
  processed=[]; audit=[]; unmatched=[]; btnDownload.disabled=true; btnProcess.disabled=true;
  statsEl.textContent="";
  const f=e.target.files[0];
  if(!f){ statusEl.textContent="No file loaded."; return; }
  statusEl.textContent="Reading file…";
  const data=await f.arrayBuffer();
  wb=XLSX.read(data,{type:"array"});
  // sheet list
  sheetSel.innerHTML = wb.SheetNames.map(n=>`<option>${n}</option>`).join("");
  sheetSel.value = wb.SheetNames[0];
  loadActiveSheet();
});
sheetSel.addEventListener("change", loadActiveSheet);

function loadActiveSheet(){
  const ws = wb.Sheets[sheetSel.value];
  const {headers: hdr, rows} = inferHeaderAndRows(ws);
  headers=hdr; rawRows=rows;
  autoMap();
  statusEl.textContent = `Loaded ${rawRows.length} rows from "${sheetSel.value}". Map columns and click Process.`;
  btnProcess.disabled=false;
  btnExportCache.disabled = false;
}

/*** --- Cache ops UI --- ***/
btnExportCache.addEventListener("click", ()=>{
  const blob = new Blob([JSON.stringify(getCache(),null,2)],{type:"application/json"});
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  a.download="crossref_cache.json";
  a.click();
});
btnClearCache.addEventListener("click", ()=>{
  localStorage.removeItem(CACHE_KEY);
  alert("Cache cleared.");
});

/*** --- Helpers --- ***/
function yearOkFromIssued(issued, y, tol){
  if(!y||!issued||!issued["date-parts"]) return false;
  const cand = issued["date-parts"][0]?.[0];
  if(typeof cand!=="number") return false;
  return Math.abs(cand - parseInt(y,10)) <= parseInt(tol,10);
}

/*** --- MAIN --- ***/
async function processAll(){
  const mailto = mailtoEl.value.trim();
  if(!mailto){ alert("Please enter a contact email for Crossref requests."); return; }

  const optCrossref = document.getElementById("opt_useCrossref").checked;
  const fixTitle = document.getElementById("opt_fixTitle").checked;
  const preferDOITitle = document.getElementById("opt_preferDOITitle").checked;
  const fixAuthors = document.getElementById("opt_fixAuthors").checked;
  const threshold = parseFloat(thr.value);
  const yearTol = parseInt(tolYearEl.value||"0",10);

  const hTitle=selTitle.value, hAuthors=selAuthors.value, hDOI=selDOI.value;
  const hISSN=selISSN.value, hISBN=selISBN.value, hType=selType.value, hYear=selYear.value;

  if(!hTitle || !hAuthors || !hDOI){ alert("Please map Title, Authors and DOI columns."); return; }

  processed=[]; audit=[]; unmatched=[];
  progWrap.style.display="block"; prog.value=0; prog.max=rawRows.length;
  statusEl.textContent="Processing…";

  let cByDOI=0, cByTitle=0, cUnmatched=0;

  for(let i=0;i<rawRows.length;i++){
    const r=rawRows[i];
    let title=normSpace(r[hTitle]), authors=normSpace(r[hAuthors]), doiRaw=normSpace(r[hDOI]);
    let issnLocal=normSpace(hISSN?r[hISSN]:""), isbnLocal=normSpace(hISBN?r[hISBN]:""), typeLocal=normSpace(hType?r[hType]:""), yearLocal=normSpace(hYear?r[hYear]:"");
    let sourceTitle = sourceTitleGuess ? normSpace(r[sourceTitleGuess]) : "";

    const doi = doiNormalize(doiRaw);
    let pub="", issn=issnLocal, isbn=isbnLocal, cleanAuthors=authors, cleanTitle=title, pubType=typeLocal;
    let matchMethod="none", matchConf=0, matchNote="";

    if(fixTitle) cleanTitle = properCaseTitle(title);
    if(fixAuthors) cleanAuthors = normalizeAuthors(authors);

    if(optCrossref){
      let meta=null;

      if(doi){
        meta = await fetchCrossrefByDOI(doi, mailto);
        await new Promise(r=>setTimeout(r, POLITE_DELAY_MS));
        if(meta){ matchMethod="doi"; matchConf=1.0; }
      } else if(title){
        const items = await searchCrossrefByTitle({
          title, firstAuthor:firstAuthorSurnameGuess(authors),
          mailto, pubTypeGuess:typeLocal, year:yearLocal, yearTol:yearTol
        });
        await new Promise(r=>setTimeout(r, POLITE_DELAY_MS));
        if(items && items.length){
          const q = normTitleForMatch(title);
          const fa = firstAuthorSurnameGuess(authors);
          let best=null, bestScore=0, bestYearOk=false, bestAuthorHit=false;
          items.forEach(it=>{
            const itTitle = pick(it.title)[0] || "";
            const itSub   = pick(it.subtitle)[0] || "";
            const full    = itSub ? (itTitle + ": " + itSub) : itTitle;
            const t = normTitleForMatch(full);
            const jac = jaccard(q,t);
            const aHit = fa && Array.isArray(it.author) ? it.author.some(a=>(a.family||a.name||"").toLowerCase().includes(fa)) : false;
            const yOk = hYear ? yearOkFromIssued(it.issued, yearLocal, yearTol) : false;
            const conf = confidenceFromFeatures({jac,authorHit:aHit,yearOk:yOk});
            if(conf>bestScore){ bestScore=conf; best=it; bestAuthorHit=aHit; bestYearOk=yOk; }
          });
          if(best && bestScore>=threshold){
            meta=best; matchMethod="title"; matchConf=Number(bestScore.toFixed(3));
            matchNote = `authorMatch=${bestAuthorHit}, yearOk=${bestYearOk}`;
          }
        }
      }

      if(meta){
        if(meta.publisher) pub=meta.publisher;
        const issnArr = pick(meta.ISSN); if(issnArr.length) issn=joinUnique([issn,...issnArr]);
        const isbns = pick(meta.ISBN);   if(isbns.length)   isbn=joinUnique([isbn,...isbns]);
        if(meta.type) pubType = pubType || meta.type;

        // ---- CleanAuthors from Crossref (if available)
        if(fixAuthors && Array.isArray(meta.author) && meta.author.length){
          const names = meta.author.map(a=>{
            const given=normSpace(a.given||""), family=normSpace(a.family||"");
            let fn = normSpace(`${given} ${family}`.trim());
            if(!fn && a.name) fn = toFirstLast_one(a.name);
            return fn.split(" ").map(p=>particles.has(p.toLowerCase())?p.toLowerCase():capitalizeWord(p)).join(" ");
          });
          cleanAuthors = names.filter(Boolean).join("; ");
        }

        // ---- CleanTitle from Crossref (title + subtitle) if preferred
        if(preferDOITitle){
          const full = buildCrossrefFullTitle(meta);
          if(full) cleanTitle = fixTitle ? properCaseTitle(full) : full;
        }

        // Container title
        if(!sourceTitle){
          const container = (meta["container-title"] && meta["container-title"][0]) ? meta["container-title"][0] : "";
          sourceTitle = normSpace(container);
        }
      }
    }

    if(matchMethod==="doi") cByDOI++;
    else if(matchMethod==="title") cByTitle++;
    else cUnmatched++;

    processed.push({
      CleanTitle: cleanTitle,
      CleanAuthors: cleanAuthors,
      DOI: doi || doiRaw,
      Publisher: pub,
      ISSN: issn,
      ISBN: isbn,
      PubType: pubType,
      SourceTitle: sourceTitle,
      MatchMethod: matchMethod,
      MatchConfidence: matchConf,
      MatchNote: matchNote,
      _OriginalTitle: title,
      _OriginalAuthors: authors,
      _Year: yearLocal
    });

    audit.push({
      Row:i+1, Title:title, DOI_in:doiRaw, DOI_norm:doi||"", FirstAuthorGuess:firstAuthorSurnameGuess(authors),
      Year:yearLocal, Used:matchMethod, Confidence:matchConf, Note:matchNote, Publisher:pub, ISSN:issn, ISBN:isbn
    });

    if(matchMethod==="none" && !doi) unmatched.push(r);
    prog.value=i+1;
  }

  // ---- Duplicate tagging
  const dupCounts = {};
  processed.forEach(r => {
    r._DupKey = makeDupKey(r);
    if(!r._DupKey) return;
    dupCounts[r._DupKey] = (dupCounts[r._DupKey] || 0) + 1;
  });
  const dupRows = [];
  processed.forEach(r => {
    r.IsDuplicate  = dupCounts[r._DupKey] > 1 ? "Yes" : "";
    r.DupGroupSize = dupCounts[r._DupKey] || 0;
    if (dupCounts[r._DupKey] > 1) dupRows.push(r);
  });
  const dupGroups = new Set(dupRows.map(r => r._DupKey)).size;

  statusEl.textContent = `Done. ${processed.length} rows.`;
  statsEl.innerHTML = `<span class="stat">Matched by DOI: <b>${cByDOI}</b></span>
                       <span class="stat">Matched by Title: <b>${cByTitle}</b></span>
                       <span class="stat">Unmatched: <b>${cUnmatched}</b></span>
                       <span class="stat">Duplicates: <b>${dupRows.length}</b> rows in <b>${dupGroups}</b> groups</span>`;
  btnDownload.disabled=false;
}

/*** --- Unique authors sheet --- ***/
function buildUniqueAuthors(){
  const map = new Map();
  processed.forEach(r=>{
    const list = (r.CleanAuthors||"").split(";").map(s=>s.trim()).filter(Boolean);
    list.forEach(name=>{
      const key = name.toLowerCase().replace(/[^\w]/g,"");
      const v = map.get(key) || {CanonicalAuthor:name, Occurrences:0, Variants:new Set()};
      v.Occurrences += 1;
      v.Variants.add(name);
      map.set(key,v);
    });
  });
  return Array.from(map.values()).map(v=>({
    CanonicalAuthor: v.CanonicalAuthor,
    Occurrences: v.Occurrences,
    SeenVariants: Array.from(v.Variants).sort().join("; ")
  })).sort((a,b)=>a.CanonicalAuthor.localeCompare(b.CanonicalAuthor));
}

/*** --- Download --- ***/
function downloadXLSX(){
  const wb2 = XLSX.utils.book_new();

  // Deduped = keep first per group
  const seen = new Set();
  const deduped = processed.filter(r => {
    const k = r._DupKey || "";
    if (!k) return true;
    if (seen.has(k)) return false;
    seen.add(k);
    return true;
  });

  // Write sheets
  XLSX.utils.book_append_sheet(wb2, XLSX.utils.json_to_sheet(deduped), "Cleaned");     // primary clean output
  XLSX.utils.book_append_sheet(wb2, XLSX.utils.json_to_sheet(processed), "AllRows");
  const dupOnly = processed.filter(r => r.IsDuplicate === "Yes");
  if (dupOnly.length) XLSX.utils.book_append_sheet(wb2, XLSX.utils.json_to_sheet(dupOnly), "Duplicates");
  XLSX.utils.book_append_sheet(wb2, XLSX.utils.json_to_sheet(buildUniqueAuthors()), "UniqueAuthors");
  if(unmatched.length) XLSX.utils.book_append_sheet(wb2, XLSX.utils.json_to_sheet(unmatched), "Unmatched");
  XLSX.utils.book_append_sheet(wb2, XLSX.utils.json_to_sheet(audit), "Audit");

  XLSX.writeFile(wb2, "books_chapters_enriched_clean.xlsx");
}

/*** --- Wire buttons --- ***/
document.getElementById("btnProcess").addEventListener("click", processAll);
document.getElementById("btnDownload").addEventListener("click", downloadXLSX);
</script>
</body>
</html>
