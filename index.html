<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Books & Chapters — Enrich (DOI/Title) · Clean · Audit · Review · ROR</title>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<style>
  :root{--bg:#0b1020;--panel:#121833;--card:#0f152a;--line:#1f2747;--ink:#e9eef9;--mut:#9fb0e1;--accent:#1463ff}
  *{box-sizing:border-box}
  body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--ink);margin:0}
  .wrap{max-width:1200px;margin:24px auto;padding:24px;background:var(--panel);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  h1{margin:0 0 12px;font-size:22px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:14px;margin-top:12px}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:14px}
  .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:14px}
  label{font-size:13px;opacity:.92}
  select,input[type="text"],input[type="email"],input[type="number"],input[type="range"]{width:100%;padding:10px;border-radius:10px;border:1px solid #31406d;background:#0b1130;color:var(--ink)}
  .pill{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border:1px solid #34406b;border-radius:999px;font-size:12px;margin:4px 6px 0 0}
  .muted{font-size:12px;color:var(--mut)}
  .btn{padding:10px 14px;border:1px solid #2a8cff;background:var(--accent);color:#fff;border-radius:10px;cursor:pointer}
  .btn.secondary{background:transparent;border-color:#3a4d86}
  .btn:disabled{opacity:.55;cursor:not-allowed}
  progress{width:100%}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .kv{display:flex;gap:10px;flex-wrap:wrap}
  .kv .k{min-width:170px}
  .stat{display:inline-block;margin-right:14px;font-size:12px;color:var(--mut)}
  .preview{font-size:12px;color:var(--mut);margin-top:6px}
  .cand{border:1px solid #2a355f;border-radius:10px;padding:10px;margin:8px 0;background:#0b1130}
  .cand h4{margin:0 0 6px 0;font-size:14px}
  .flex{display:flex;gap:10px;align-items:center}
  .space{display:flex;justify-content:space-between;gap:10px;align-items:center}
  .nowrap{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
</style>
</head>
<body>
<div class="wrap">
  <h1>Books & Chapters — Enrich (DOI/Title), Clean, Audit, Review, ROR</h1>

  <!-- Load + sheet -->
  <div class="card">
    <div class="row">
      <div>
        <label><b>Upload file (CSV/XLSX)</b></label>
        <input id="file" type="file" accept=".csv,.xlsx,.xls" />
        <div class="muted">Needs columns for Title, Authors, DOI (ISSN/ISBN/Year optional).</div>
      </div>
      <div>
        <label><b>Contact email for Crossref (required)</b></label>
        <input id="mailto" type="email" placeholder="you@org.ac.in" />
        <div class="muted">Used only in the Crossref request header (polite etiquette).</div>
      </div>
    </div>
    <div class="row" style="margin-top:10px">
      <div>
        <label>Sheet</label>
        <select id="sheetSel"></select>
      </div>
      <div>
        <div id="hdrPreview" class="preview"></div>
      </div>
    </div>
  </div>

  <!-- Column mapping -->
  <div class="card">
    <div class="row3">
      <div><label>Title column</label><select id="colTitle"></select></div>
      <div><label>Authors column</label><select id="colAuthors"></select></div>
      <div><label>DOI column</label><select id="colDOI"></select></div>
    </div>
    <div class="row3" style="margin-top:10px">
      <div><label>ISSN column (optional)</label><select id="colISSN"></select></div>
      <div><label>ISBN column (optional)</label><select id="colISBN"></select></div>
      <div><label>Publication type column (optional)</label><select id="colType"></select></div>
    </div>
    <div class="row3" style="margin-top:10px">
      <div><label>Year column (optional)</label><select id="colYear"></select></div>
      <div class="k">
        <label>Title-match threshold <span id="thrVal" class="muted"></span></label>
        <input id="thr" type="range" min="0.50" max="0.90" step="0.01" value="0.68" />
        <div class="muted">Higher = stricter title matches (used when DOI missing)</div>
      </div>
      <div class="k">
        <label>Year tolerance (±)</label>
        <input id="tolYear" type="number" min="0" max="3" value="1" />
        <div class="muted">Used only if Year column is mapped</div>
      </div>
    </div>
  </div>

  <!-- ROR / Affiliation filters -->
  <div class="card">
    <div class="row">
      <div>
        <label><b>Affiliation keywords</b> (comma-separated)</label>
        <input id="affKeys" type="text" placeholder="UPES, University of Petroleum and Energy Studies, Dehradun" />
        <div class="muted">Boosts matches where author affiliations contain these terms.</div>
      </div>
      <div>
        <label><b>ROR IDs</b> (comma-separated)</label>
        <input id="rorIds" type="text" placeholder="05dxps055, 03yrm5c26" />
        <div class="muted">Boosts matches containing these RORs; format can be bare ID or full https://ror.org/…</div>
      </div>
    </div>
    <div class="kv" style="margin-top:6px">
      <span class="pill"><input id="cbStrictAff" type="checkbox" /> Require affiliation hit (drop candidates without a match)</span>
      <span class="pill"><input id="cbQueryAff" type="checkbox" checked /> Hint Crossref with affiliation in query</span>
    </div>
  </div>

  <!-- Options + actions -->
  <div class="card">
    <div class="kv">
      <span class="pill"><input id="opt_fixTitle" type="checkbox" checked /> Proper-case titles (keep ACRONYMS; small articles/preps/conj lowercase)</span>
      <span class="pill"><input id="opt_fixAuthors" type="checkbox" checked /> Normalize authors → “First Last”</span>
      <span class="pill"><input id="opt_useCrossref" type="checkbox" checked /> Enrich from Crossref</span>
      <span class="pill"><input id="opt_useCache" type="checkbox" checked /> Cache lookups (localStorage)</span>
    </div>
    <div class="space" style="margin-top:10px">
      <div>
        <span id="stats" class="preview"></span>
      </div>
      <div class="flex">
        <button id="btnOpenReview" class="btn secondary" disabled>Open Review Queue</button>
        <button id="btnExportCache" class="btn secondary" disabled>Export cache</button>
        <button id="btnClearCache" class="btn secondary">Clear cache</button>
        <button id="btnProcess" class="btn" disabled>Process</button>
        <button id="btnDownload" class="btn secondary" disabled>Download XLSX</button>
      </div>
    </div>
    <div id="status" class="muted" style="margin-top:8px">No file loaded.</div>
    <div id="progWrap" style="display:none;margin-top:8px"><progress id="prog" value="0" max="100"></progress></div>
  </div>

  <!-- Review Queue -->
  <div class="card" id="reviewCard" style="display:none">
    <div class="space">
      <div><b>Review Queue</b> — <span id="revCounter" class="muted"></span></div>
      <div class="flex">
        <button id="revPrev" class="btn secondary">Prev</button>
        <button id="revNext" class="btn secondary">Next</button>
      </div>
    </div>
    <div id="revContext" class="preview" style="margin:6px 0 10px 0"></div>
    <div class="row">
      <div>
        <label>Edit search (title)</label>
        <input id="revSearchTitle" type="text" />
      </div>
      <div>
        <label>First author (optional)</label>
        <input id="revSearchAuthor" type="text" />
      </div>
    </div>
    <div class="flex" style="margin-top:8px">
      <button id="revSearch" class="btn secondary">Search again</button>
      <div class="muted">Uses your filters (year tolerance, ROR, affiliation)</div>
    </div>
    <div id="revCands" style="margin-top:10px"></div>
    <div class="space" style="margin-top:10px">
      <div class="muted nowrap">Pick a candidate then click Apply. Or Skip to leave this row unchanged.</div>
      <div class="flex">
        <button id="revApply" class="btn">Apply</button>
        <button id="revSkip" class="btn secondary">Skip</button>
      </div>
    </div>
  </div>

  <div class="card">
    <b>Outputs</b>
    <div class="muted">
      <ul>
        <li><b>Cleaned</b> — CleanTitle, CleanAuthors, DOI, Publisher, ISSN, ISBN, PubType, SourceTitle, MatchMethod, MatchConfidence, MatchNote</li>
        <li><b>UniqueAuthors</b> — CanonicalAuthor, Occurrences, SeenVariants</li>
        <li><b>Unmatched</b> — rows without DOI and no confident title match</li>
        <li><b>Audit</b> — per-row enrichment details (for QA)</li>
      </ul>
      Host safely on <span class="mono">GitHub Pages</span> — all processing is client-side.
    </div>
  </div>
</div>

<script>
/* ================================
   Scientist-Programmer + Review + ROR
   ================================ */

let wb=null, rawRows=[], headers=[], processed=[], audit=[], unmatched=[];
let sourceTitleGuess=null;
let reviewItems=[], reviewIndex=0, reviewSelection=-1;

/*** --- Config --- ***/
const POLITE_DELAY_MS = 220;             // Crossref-friendly pacing
const CACHE_KEY = "crCache_v3";          // localStorage key

/*** --- Utilities --- ***/
const stopwords = new Set([
  "a","an","the","and","but","or","nor","for","so","yet",
  "at","by","in","of","off","on","per","to","up","via","vs","as",
  "over","into","onto","from","than","with","without","within","about","across","after","before","between","through","under","above","around"
]);
const particles = new Set(["van","von","de","del","della","der","den","da","dos","das","di","al","bin","ibn","la","le","du","ter"]);

function normSpace(s){ return (s??"").toString().replace(/\s+/g," ").trim(); }
function isAcronym(w){ return /^[A-Z0-9]{2,}$/.test(w); }
function capitalizeWord(w){
  if(!w) return w;
  if(isAcronym(w)) return w;
  if(w.includes("-")) return w.split("-").map(capitalizeWord).join("-");
  return w.charAt(0).toUpperCase() + w.slice(1).toLowerCase();
}
function properCaseTitle(str){
  str = normSpace(str); if(!str) return str;
  const words = str.split(" ");
  return words.map((w,i)=>{
    const base = w.replace(/[^\w\-']/g,"");
    if(i!==0 && i!==(words.length-1) && stopwords.has(base.toLowerCase())) return w.toLowerCase();
    return capitalizeWord(w);
  }).join(" ");
}
function toFirstLast_one(name){
  name = normSpace(name.replace(/\s*\.\s*/g,".").replace(/\s+,/g,","));
  if(!name) return "";
  if(name.includes(",")){
    const [last,rest]=name.split(",",2);
    let parts = normSpace(`${rest||""} ${last}`).split(" ").filter(Boolean);
    parts = parts.map((p)=> particles.has(p.toLowerCase()) ? p.toLowerCase() : capitalizeWord(p));
    return parts.join(" ");
  }
  return name.split(" ").map(p=>particles.has(p.toLowerCase())?p.toLowerCase():capitalizeWord(p)).join(" ");
}
function normalizeAuthors(str){
  if(!str) return "";
  let parts=[];
  if(str.includes("|")) parts=str.split("|");
  else if(str.includes(";")) parts=str.split(";");
  else parts=str.split(/\s+and\s+|\s*&\s*/i);
  return parts.map(x=>x.trim()).filter(Boolean)
    .map(toFirstLast_one)
    .map(normSpace)
    .join("; ");
}
function firstAuthorSurnameGuess(str){
  if(!str) return "";
  let first = str.split("|")[0].split(";")[0].trim();
  if(!first) return "";
  if(first.includes(",")) return normSpace(first.split(",")[0]).toLowerCase();
  const toks = first.split(" ").filter(Boolean);
  return toks.length ? toks[toks.length-1].toLowerCase() : "";
}
function pick(a){ return Array.isArray(a)?a:(a?[a]:[]); }
function joinUnique(arr){ return Array.from(new Set(arr.filter(Boolean).map(x=>x.toString().trim()))).join("; "); }
function doiNormalize(d){ if(!d) return ""; d=d.toString().trim(); return d.replace(/^https?:\/\/(dx\.)?doi\.org\//i,""); }

/*** --- Title similarity & scoring --- ***/
function normTitleForMatch(s){
  return normSpace(s.toLowerCase()
    .replace(/[\u2010-\u2015]/g,"-")
    .replace(/[^\w\s-]/g,""))
    .split(" ")
    .filter(w=>w && !stopwords.has(w))
    .join(" ");
}
function jaccard(a,b){
  const A=new Set(a.split(" ").filter(Boolean));
  const B=new Set(b.split(" ").filter(Boolean));
  const inter=[...A].filter(x=>B.has(x)).length;
  const uni=new Set([...A,...B]).size||1;
  return inter/uni;
}
function confidenceFromFeatures({jac, authorHit, yearOk, affHit, rorHit}){
  let s = jac;
  if(authorHit) s += 0.12;
  if(yearOk)    s += 0.08;
  if(affHit)    s += 0.08;
  if(rorHit)    s += 0.10;
  return Math.max(0, Math.min(1, s));
}

/*** --- Affiliation helpers --- ***/
function splitCsvInput(val){
  return normSpace(val).split(",").map(x=>x.trim()).filter(Boolean);
}
function presentRORs(raw){
  // normalize to bare IDs (last 9 chars) or keep as-is if already short
  return splitCsvInput(raw).map(r=>{
    const m = r.match(/([0-9a-hjkmnp-z]{9})$/i);
    return m ? m[1].toLowerCase() : r.toLowerCase();
  });
}
function affHitInItem(item, keys){
  if(!keys.length || !Array.isArray(item.author)) return false;
  const K = keys.map(k=>k.toLowerCase());
  return item.author.some(a => Array.isArray(a.affiliation) && a.affiliation.some(af => {
    const name = (af.name||"").toLowerCase();
    return K.some(k => name.includes(k));
  }));
}
function rorHitInItem(item, rorIds){
  if(!rorIds.length || !Array.isArray(item.author)) return false;
  return item.author.some(a => Array.isArray(a.affiliation) && a.affiliation.some(af => {
    const id = (af.id||"").toLowerCase();
    const name = (af.name||"").toLowerCase();
    return rorIds.some(r => id.endsWith(r) || name.includes(r)); // tolerate missing id by name fallback
  }));
}

/*** --- Cache --- ***/
function getCache(){ try{ return JSON.parse(localStorage.getItem(CACHE_KEY)||"{}"); }catch{ return {}; } }
function setCache(o){ try{ localStorage.setItem(CACHE_KEY, JSON.stringify(o)); }catch{} }
function cacheGet(k){ return getCache()[k]; }
function cacheSet(k,v){ const c=getCache(); c[k]=v; setCache(c); }

/*** --- Crossref API --- ***/
async function fetchCrossrefByDOI(doi, mailto){
  const key = `doi::${doi.toLowerCase()}`;
  if(document.getElementById("opt_useCache").checked){
    const hit = cacheGet(key); if(hit) return hit;
  }
  const res = await fetch(`https://api.crossref.org/works/${encodeURIComponent(doi)}`,{
    headers:{
      "User-Agent":`UPES-RnD-Scientist/1.4 (mailto:${mailto||"unknown@example.com"})`,
      "Accept":"application/json"
    }
  });
  if(!res.ok) return null;
  const j = await res.json();
  const msg = j?.message||null;
  if(msg && document.getElementById("opt_useCache").checked) cacheSet(key,msg);
  return msg;
}

async function searchCrossrefByTitle({title, firstAuthor, mailto, pubTypeGuess, year, yearTol, affKeys, rorIds, hintQueryAff}){
  const affStr = affKeys.join(" ");
  const key = `title::${title.toLowerCase()}::${(firstAuthor||"").toLowerCase()}::${pubTypeGuess||""}::${year||""}::${yearTol||0}::${affStr}::${rorIds.join("|")}`;
  if(document.getElementById("opt_useCache").checked){
    const hit = cacheGet(key); if(hit) return hit;
  }
  const params=new URLSearchParams();
  params.set("query.title", title);
  if(firstAuthor) params.set("query.author", firstAuthor);
  if(hintQueryAff && affStr) params.set("query.affiliation", affStr);
  params.set("rows","10");
  params.set("select","title,DOI,author,issued,publisher,type,ISSN,ISBN,container-title,score");

  const filters=[];
  if(pubTypeGuess && /book/i.test(pubTypeGuess)) filters.push("type:book,type:book-chapter");
  if(year){
    const y = parseInt(year,10), tol = Math.max(0, parseInt(yearTol||0,10));
    filters.push(`from-pub-date:${y - tol}-01-01`);
    filters.push(`until-pub-date:${y + tol}-12-31`);
  }
  if(filters.length) params.set("filter", filters.join(","));

  const res = await fetch(`https://api.crossref.org/works?${params.toString()}`,{
    headers:{
      "User-Agent":`UPES-RnD-Scientist/1.4 (mailto:${mailto||"unknown@example.com"})`,
      "Accept":"application/json"
    }
  });
  if(!res.ok) return [];
  const j = await res.json();
  const items = j?.message?.items || [];
  if(document.getElementById("opt_useCache").checked) cacheSet(key, items);
  return items;
}

/*** --- Header detection --- */
function inferHeaderAndRows(ws){
  const rows = XLSX.utils.sheet_to_json(ws,{header:1,defval:""});
  let bestIdx=0,bestScore=-1;
  const scanLimit=Math.min(rows.length,20);
  for(let i=0;i<scanLimit;i++){
    const r=rows[i]||[];
    const filled=r.filter(x=>String(x).trim()!=="").length;
    if(filled>bestScore){bestScore=filled;bestIdx=i;}
  }
  const hdr=(rows[bestIdx]||[]).map(x=>normSpace(String(x)));
  const out=[];
  for(let i=bestIdx+1;i<rows.length;i++){
    const r=rows[i]||[];
    const obj={};
    for(let c=0;c<hdr.length;c++){
      const key=hdr[c]||`Col${c+1}`;
      obj[key]=r[c]??"";
    }
    if(Object.values(obj).some(v=>String(v).trim()!=="")) out.push(obj);
  }
  return {headers: hdr.map(h=>h||"Unnamed"), rows: out};
}

/*** --- UI Refs --- ***/
const fileEl = document.getElementById("file");
const sheetSel = document.getElementById("sheetSel");
const mailtoEl = document.getElementById("mailto");
const statusEl = document.getElementById("status");
const statsEl = document.getElementById("stats");
const btnProcess = document.getElementById("btnProcess");
const btnDownload = document.getElementById("btnDownload");
const btnExportCache = document.getElementById("btnExportCache");
const btnClearCache = document.getElementById("btnClearCache");
const btnOpenReview = document.getElementById("btnOpenReview");
const prog = document.getElementById("prog");
const progWrap = document.getElementById("progWrap");
const thr = document.getElementById("thr");
const thrVal = document.getElementById("thrVal");
const tolYearEl = document.getElementById("tolYear");
const hdrPreview = document.getElementById("hdrPreview");
const affKeysEl = document.getElementById("affKeys");
const rorIdsEl = document.getElementById("rorIds");
const cbStrictAff = document.getElementById("cbStrictAff");
const cbQueryAff = document.getElementById("cbQueryAff");
thrVal.textContent = `(=${thr.value})`;
thr.addEventListener("input", ()=> thrVal.textContent=`(=${thr.value})`);

const selTitle = document.getElementById("colTitle");
const selAuthors = document.getElementById("colAuthors");
const selDOI = document.getElementById("colDOI");
const selISSN = document.getElementById("colISSN");
const selISBN = document.getElementById("colISBN");
const selType = document.getElementById("colType");
const selYear = document.getElementById("colYear");

/*** --- Mapping helpers --- ***/
function fillSelect(id, headers){
  const el = document.getElementById(id);
  el.innerHTML = '<option value="">-- none --</option>' + headers.map(h=>`<option>${h}</option>`).join("");
}
function autoMap(){
  sourceTitleGuess = headers.find(h => /source\s*title|book\s*title|journal\s*title|scopus\s*source/i.test(h)) || null;
  ["colTitle","colAuthors","colDOI","colISSN","colISBN","colType","colYear"].forEach(id=>fillSelect(id, headers));
  selTitle.value   = headers.find(h=>/^title$/i.test(h)) || headers.find(h=>/chapter|book.*title/i.test(h)) || "";
  selAuthors.value = headers.find(h=>/author/i.test(h)) || "";
  selDOI.value     = headers.find(h=>/^doi$/i.test(h)) || "";
  selISSN.value    = headers.find(h=>/issn/i.test(h)) || "";
  selISBN.value    = headers.find(h=>/isbn/i.test(h)) || "";
  selType.value    = headers.find(h=>/type/i.test(h)) || "";
  selYear.value    = headers.find(h=>/^year$|published|date/i.test(h)) || "";
  hdrPreview.textContent = headers.length ? `Detected headers: ${headers.join(" | ")}` : "";
}

/*** --- File handling --- ***/
fileEl.addEventListener("change", async (e)=>{
  processed=[]; audit=[]; unmatched=[]; reviewItems=[]; btnDownload.disabled=true; btnProcess.disabled=true; btnOpenReview.disabled=true;
  statsEl.textContent="";
  const f=e.target.files[0];
  if(!f){ statusEl.textContent="No file loaded."; return; }
  statusEl.textContent="Reading file…";
  const data=await f.arrayBuffer();
  wb=XLSX.read(data,{type:"array"});
  sheetSel.innerHTML = wb.SheetNames.map(n=>`<option>${n}</option>`).join("");
  sheetSel.value = wb.SheetNames[0];
  loadActiveSheet();
});
sheetSel.addEventListener("change", loadActiveSheet);

function loadActiveSheet(){
  const ws = wb.Sheets[sheetSel.value];
  const {headers: hdr, rows} = inferHeaderAndRows(ws);
  headers=hdr; rawRows=rows;
  autoMap();
  statusEl.textContent = `Loaded ${rawRows.length} rows from "${sheetSel.value}". Map columns and click Process.`;
  btnProcess.disabled=false;
  btnExportCache.disabled=false;
}

/*** --- Cache ops --- ***/
btnExportCache.addEventListener("click", ()=>{
  const blob = new Blob([JSON.stringify(getCache(),null,2)],{type:"application/json"});
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  a.download="crossref_cache.json";
  a.click();
});
btnClearCache.addEventListener("click", ()=>{
  localStorage.removeItem(CACHE_KEY);
  alert("Cache cleared.");
});

/*** --- Matching helpers --- ***/
function yearOkFromIssued(issued, y, tol){
  if(!y||!issued||!issued["date-parts"]) return false;
  const cand = issued["date-parts"][0]?.[0];
  if(typeof cand!=="number") return false;
  return Math.abs(cand - parseInt(y,10)) <= parseInt(tol,10);
}

/*** --- Process (with Review build) --- ***/
async function processAll(){
  const mailto = mailtoEl.value.trim();
  if(!mailto){ alert("Please enter a contact email for Crossref requests."); return; }

  const optCrossref = document.getElementById("opt_useCrossref").checked;
  const fixTitle = document.getElementById("opt_fixTitle").checked;
  const fixAuthors = document.getElementById("opt_fixAuthors").checked;
  const threshold = parseFloat(thr.value);
  const yearTol = parseInt(tolYearEl.value||"0",10);

  const hTitle=selTitle.value, hAuthors=selAuthors.value, hDOI=selDOI.value;
  const hISSN=selISSN.value, hISBN=selISBN.value, hType=selType.value, hYear=selYear.value;
  if(!hTitle || !hAuthors || !hDOI){ alert("Please map Title, Authors and DOI columns."); return; }

  const affKeys = splitCsvInput(affKeysEl.value);
  const rorIds  = presentRORs(rorIdsEl.value);
  const strictAff = cbStrictAff.checked;
  const hintQueryAff = cbQueryAff.checked;

  processed=[]; audit=[]; unmatched=[]; reviewItems=[]; reviewIndex=0;
  progWrap.style.display="block"; prog.value=0; prog.max=rawRows.length;
  statusEl.textContent="Processing…";

  let cByDOI=0, cByTitle=0, cQueued=0, cUnmatched=0;

  for(let i=0;i<rawRows.length;i++){
    const r=rawRows[i];
    let title=normSpace(r[hTitle]), authors=normSpace(r[hAuthors]), doiRaw=normSpace(r[hDOI]);
    let issnLocal=normSpace(hISSN?r[hISSN]:""), isbnLocal=normSpace(hISBN?r[hISBN]:""), typeLocal=normSpace(hType?r[hType]:""), yearLocal=normSpace(hYear?r[hYear]:"");
    let sourceTitle = sourceTitleGuess ? normSpace(r[sourceTitleGuess]) : "";

    const doi = doiNormalize(doiRaw);
    let pub="", issn=issnLocal, isbn=isbnLocal, cleanAuthors=authors, cleanTitle=title, pubType=typeLocal;
    let matchMethod="none", matchConf=0, matchNote="";

    if(fixTitle) cleanTitle = properCaseTitle(title);
    if(fixAuthors) cleanAuthors = normalizeAuthors(authors);

    if(optCrossref){
      let meta=null;

      if(doi){
        meta = await fetchCrossrefByDOI(doi, mailto);
        await new Promise(r=>setTimeout(r, POLITE_DELAY_MS));
        if(meta){ matchMethod="doi"; matchConf=1.0; }
      } else if(title){
        const items = await searchCrossrefByTitle({
          title, firstAuthor:firstAuthorSurnameGuess(authors),
          mailto, pubTypeGuess:typeLocal, year:yearLocal, yearTol,
          affKeys, rorIds, hintQueryAff
        });
        await new Promise(r=>setTimeout(r, POLITE_DELAY_MS));

        const q = normTitleForMatch(title);
        const fa = firstAuthorSurnameGuess(authors);
        let best=null, bestScore=0, bestYearOk=false, bestAuthorHit=false, bestAff=false, bestRor=false;

        const scored = items.map(it=>{
          const itTitle = pick(it.title)[0] || "";
          const t = normTitleForMatch(itTitle);
          const jac = jaccard(q,t);
          const aHit = fa && Array.isArray(it.author) ? it.author.some(a=>(a.family||a.name||"").toLowerCase().includes(fa)) : false;
          const yOk = hYear ? yearOkFromIssued(it.issued, yearLocal, yearTol) : false;
          const aHitAff = affHitInItem(it, affKeys);
          const rHit = rorHitInItem(it, rorIds);
          const conf = confidenceFromFeatures({jac,authorHit:aHit,yearOk:yOk,affHit:aHitAff,rorHit:rHit});
          return {it, conf, jac, aHit, yOk, aHitAff, rHit};
        }).filter(sc => !strictAff || sc.aHitAff || sc.rHit)
          .sort((a,b)=>b.conf-a.conf);

        if(scored.length){
          const top = scored[0];
          best = top.it; bestScore = top.conf; bestYearOk = top.yOk; bestAuthorHit = top.aHit; bestAff=top.aHitAff; bestRor=top.rHit;
        }

        if(best && bestScore>=threshold){
          meta=best; matchMethod="title"; matchConf=Number(bestScore.toFixed(3));
          matchNote = `authorMatch=${bestAuthorHit}, yearOk=${bestYearOk}, affHit=${bestAff}, rorHit=${bestRor}`;
        } else if(scored.length){
          // queue for review
          reviewItems.push({
            rowIndex:i, original:{title, authors, year:yearLocal},
            candidates: scored.slice(0,6) // top 6
          });
          cQueued++;
          matchMethod="review";
          matchConf=0;
          matchNote="Queued for review";
        }
      }

      if(meta){
        if(meta.publisher) pub=meta.publisher;
        const issnArr = pick(meta.ISSN); if(issnArr.length) issn=joinUnique([issn,...issnArr]);
        const isbns = pick(meta.ISBN);   if(isbns.length)   isbn=joinUnique([isbn,...isbns]);
        if(meta.type) pubType = pubType || meta.type;

        if(fixAuthors && Array.isArray(meta.author) && meta.author.length){
          const names = meta.author.map(a=>{
            const given=normSpace(a.given||""), family=normSpace(a.family||"");
            let fn = normSpace(`${given} ${family}`.trim());
            if(!fn && a.name) fn = toFirstLast_one(a.name);
            return fn.split(" ").map(p=>particles.has(p.toLowerCase())?p.toLowerCase():capitalizeWord(p)).join(" ");
          });
          cleanAuthors = names.filter(Boolean).join("; ");
        }
        if(fixTitle && Array.isArray(meta.title) && meta.title[0]){
          cleanTitle = properCaseTitle(meta.title[0]);
        }
        if(!sourceTitle){
          const container = (meta["container-title"] && meta["container-title"][0]) ? meta["container-title"][0] : "";
          sourceTitle = normSpace(container);
        }
      }
    }

    if(matchMethod==="doi") cByDOI++;
    else if(matchMethod==="title") cByTitle++;
    else if(matchMethod==="review") {/* queued */}
    else cUnmatched++;

    processed.push({
      CleanTitle: cleanTitle,
      CleanAuthors: cleanAuthors,
      DOI: doi || doiRaw,
      Publisher: pub,
      ISSN: issn,
      ISBN: isbn,
      PubType: pubType,
      SourceTitle: sourceTitle,
      MatchMethod: matchMethod,
      MatchConfidence: matchConf,
      MatchNote: matchNote,
      _OriginalTitle: title,
      _OriginalAuthors: authors,
      _Year: yearLocal
    });

    audit.push({
      Row:i+1, Title:title, DOI_in:doiRaw, DOI_norm:doi||"", FirstAuthorGuess:firstAuthorSurnameGuess(authors),
      Year:yearLocal, Used:matchMethod, Confidence:matchConf, Note:matchNote, Publisher:pub, ISSN:issn, ISBN:isbn
    });

    if(matchMethod==="none" && !doi) unmatched.push(r);
    prog.value=i+1;
  }

  statusEl.textContent = `Done. ${processed.length} rows.`;
  statsEl.innerHTML = `<span class="stat">By DOI: <b>${processed.filter(r=>r.MatchMethod==="doi").length}</b></span>
                       <span class="stat">By Title: <b>${processed.filter(r=>r.MatchMethod==="title").length}</b></span>
                       <span class="stat">Queued for Review: <b>${reviewItems.length}</b></span>
                       <span class="stat">Unmatched: <b>${processed.filter(r=>r.MatchMethod==="none").length}</b></span>`;
  btnDownload.disabled=false;
  btnOpenReview.disabled = reviewItems.length===0;
}

/*** --- Unique authors --- ***/
function buildUniqueAuthors(){
  const map = new Map();
  processed.forEach(r=>{
    const list = (r.CleanAuthors||"").split(";").map(s=>s.trim()).filter(Boolean);
    list.forEach(name=>{
      const key = name.toLowerCase().replace(/[^\w]/g,"");
      const v = map.get(key) || {CanonicalAuthor:name, Occurrences:0, Variants:new Set()};
      v.Occurrences += 1; v.Variants.add(name); map.set(key,v);
    });
  });
  return Array.from(map.values()).map(v=>({
    CanonicalAuthor: v.CanonicalAuthor,
    Occurrences: v.Occurrences,
    SeenVariants: Array.from(v.Variants).sort().join("; ")
  })).sort((a,b)=>a.CanonicalAuthor.localeCompare(b.CanonicalAuthor));
}

/*** --- Download --- ***/
function downloadXLSX(){
  const wb2 = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb2, XLSX.utils.json_to_sheet(processed), "Cleaned");
  XLSX.utils.book_append_sheet(wb2, XLSX.utils.json_to_sheet(buildUniqueAuthors()), "UniqueAuthors");
  if(unmatched.length) XLSX.utils.book_append_sheet(wb2, XLSX.utils.json_to_sheet(unmatched), "Unmatched");
  if(audit.length)     XLSX.utils.json_to_sheet(audit);
  XLSX.utils.book_append_sheet(wb2, XLSX.utils.json_to_sheet(audit), "Audit");
  XLSX.writeFile(wb2, "books_chapters_enriched_clean.xlsx");
}

/*** --- Review Queue UI --- ***/
const reviewCard = document.getElementById("reviewCard");
const revCounter = document.getElementById("revCounter");
const revContext = document.getElementById("revContext");
const revCands = document.getElementById("revCands");
const revPrev = document.getElementById("revPrev");
const revNext = document.getElementById("revNext");
const revApply = document.getElementById("revApply");
const revSkip = document.getElementById("revSkip");
const revSearch = document.getElementById("revSearch");
const revSearchTitle = document.getElementById("revSearchTitle");
const revSearchAuthor = document.getElementById("revSearchAuthor");

btnOpenReview.addEventListener("click", ()=>{
  if(reviewItems.length===0){ alert("Nothing to review."); return; }
  reviewIndex=0; reviewSelection=-1;
  renderReview();
  reviewCard.style.display="block";
  window.scrollTo({top:reviewCard.offsetTop-10, behavior:"smooth"});
});

function renderReview(){
  const it = reviewItems[reviewIndex];
  revCounter.textContent = `Item ${reviewIndex+1} of ${reviewItems.length}`;
  revContext.innerHTML = `<b>Original title:</b> ${it.original.title} 
    ${it.original.year?`<span class="muted"> (Year: ${it.original.year})</span>`:""}<br/>
    <b>First author (guess):</b> ${firstAuthorSurnameGuess(it.original.authors)||"<i>n/a</i>"}`;
  revSearchTitle.value = it.original.title;
  revSearchAuthor.value = firstAuthorSurnameGuess(it.original.authors)||"";
  reviewSelection = -1;
  revCands.innerHTML = it.candidates.map((c,idx)=>candHTML(c, idx)).join("");
}

function candHTML(c, idx){
  const title = (pick(c.it.title)[0]||"").trim();
  const auth = (Array.isArray(c.it.author)? c.it.author.slice(0,4).map(a=>[a.given,a.family].filter(Boolean).join(" ")).join("; ") : "");
  const year = (c.it.issued && c.it.issued["date-parts"] && c.it.issued["date-parts"][0] ? c.it.issued["date-parts"][0][0] : "");
  return `
    <label class="cand">
      <div class="flex">
        <input type="radio" name="candPick" value="${idx}" />
        <div style="width:100%">
          <h4 class="nowrap" title="${title}">${title}</h4>
          <div class="muted nowrap"><b>DOI:</b> ${c.it.DOI||"<i>—</i>"} &nbsp; | &nbsp; <b>Publisher:</b> ${c.it.publisher||"<i>—</i>"} &nbsp; | &nbsp; <b>Year:</b> ${year||"<i>—</i>"}</div>
          <div class="muted nowrap"><b>Authors:</b> ${auth||"<i>—</i>"}</div>
          <div class="muted"><b>Confidence:</b> ${c.conf.toFixed(3)} &nbsp; <b>Signals</b> 
            [Jaccard=${c.jac.toFixed(3)}; author=${c.aHit?"✓":"–"}; year=${c.yOk?"✓":"–"}; aff=${c.aHitAff?"✓":"–"}; ROR=${c.rHit?"✓":"–"}]
          </div>
        </div>
      </div>
    </label>
  `;
}

revCands.addEventListener("change",(e)=>{
  if(e.target.name==="candPick") reviewSelection = parseInt(e.target.value,10);
});

revPrev.addEventListener("click", ()=>{
  if(reviewIndex>0){ reviewIndex--; renderReview(); }
});
revNext.addEventListener("click", ()=>{
  if(reviewIndex<reviewItems.length-1){ reviewIndex++; renderReview(); }
});

revSearch.addEventListener("click", async ()=>{
  const it = reviewItems[reviewIndex];
  const mailto = mailtoEl.value.trim();
  const yearTol = parseInt(tolYearEl.value||"0",10);
  const affKeys = splitCsvInput(affKeysEl.value);
  const rorIds  = presentRORs(rorIdsEl.value);
  const strictAff = cbStrictAff.checked;
  const hintQueryAff = cbQueryAff.checked;

  const items = await searchCrossrefByTitle({
    title: revSearchTitle.value,
    firstAuthor: revSearchAuthor.value,
    mailto,
    pubTypeGuess: selType.value,
    year: (selYear.value? reviewItems[reviewIndex].original.year : ""),
    yearTol,
    affKeys, rorIds, hintQueryAff
  });
  await new Promise(r=>setTimeout(r,POLITE_DELAY_MS));

  // re-score with current settings
  const q = normTitleForMatch(revSearchTitle.value);
  const fa = revSearchAuthor.value.toLowerCase();
  const scored = items.map(it2=>{
    const itTitle = pick(it2.title)[0]||"";
    const t = normTitleForMatch(itTitle);
    const jac=jaccard(q,t);
    const aHit = fa && Array.isArray(it2.author) ? it2.author.some(a=>(a.family||a.name||"").toLowerCase().includes(fa)) : false;
    const yOk = selYear.value ? yearOkFromIssued(it2.issued, reviewItems[reviewIndex].original.year, parseInt(tolYearEl.value||"0",10)) : false;
    const aHitAff = affHitInItem(it2, splitCsvInput(affKeysEl.value));
    const rHit = rorHitInItem(it2, presentRORs(rorIdsEl.value));
    const conf = confidenceFromFeatures({jac,authorHit:aHit,yearOk:yOk,affHit:aHitAff,rorHit:rHit});
    return {it:it2, conf, jac, aHit, yOk, aHitAff, rHit};
  }).filter(sc => !strictAff || sc.aHitAff || sc.rHit)
    .sort((a,b)=>b.conf-a.conf);

  reviewItems[reviewIndex].candidates = scored.slice(0,6);
  renderReview();
});

revApply.addEventListener("click", ()=>{
  if(reviewSelection<0){ alert("Pick a candidate first."); return; }
  const item = reviewItems[reviewIndex];
  const cand = item.candidates[reviewSelection].it;
  const idx = item.rowIndex;

  // apply to processed[idx]
  const row = processed[idx];
  // Publisher/IDs/type/source
  row.Publisher = cand.publisher || row.Publisher;
  row.ISSN = joinUnique([row.ISSN, ...pick(cand.ISSN)]);
  row.ISBN = joinUnique([row.ISBN, ...pick(cand.ISBN)]);
  row.PubType = row.PubType || cand.type || row.PubType;
  if(!row.SourceTitle){
    const container = (cand["container-title"] && cand["container-title"][0]) ? cand["container-title"][0] : "";
    row.SourceTitle = normSpace(container);
  }
  if(cand.DOI && !row.DOI) row.DOI = cand.DOI;

  // Authors + Title (clean)
  if(Array.isArray(cand.author) && cand.author.length){
    const names = cand.author.map(a=>{
      const given=normSpace(a.given||""), family=normSpace(a.family||"");
      let fn = normSpace(`${given} ${family}`.trim());
      if(!fn && a.name) fn = toFirstLast_one(a.name);
      return fn.split(" ").map(p=>particles.has(p.toLowerCase())?p.toLowerCase():capitalizeWord(p)).join(" ");
    });
    row.CleanAuthors = names.filter(Boolean).join("; ");
  }
  if(Array.isArray(cand.title) && cand.title[0]){
    row.CleanTitle = properCaseTitle(cand.title[0]);
  }

  row.MatchMethod = "review-accepted";
  row.MatchConfidence = 0.0;
  row.MatchNote = "Accepted by reviewer";

  audit.push({
    Row: idx+1, Title: row._OriginalTitle, DOI_in: "", DOI_norm: row.DOI||"",
    FirstAuthorGuess: firstAuthorSurnameGuess(row._OriginalAuthors),
    Year: row._Year, Used: "review-accepted", Confidence: 0, 
    Note: "Reviewer override", Publisher: row.Publisher, ISSN: row.ISSN, ISBN: row.ISBN
  });

  // advance
  if(reviewIndex<reviewItems.length-1){ reviewIndex++; renderReview(); }
  else { reviewCard.style.display="none"; alert("Review queue completed."); }
});

revSkip.addEventListener("click", ()=>{
  if(reviewIndex<reviewItems.length-1){ reviewIndex++; renderReview(); }
  else { reviewCard.style.display="none"; alert("Review queue completed."); }
});

/*** --- Wire main buttons --- ***/
document.getElementById("btnProcess").addEventListener("click", processAll);
document.getElementById("btnDownload").addEventListener("click", downloadXLSX);
</script>
</body>
</html>
